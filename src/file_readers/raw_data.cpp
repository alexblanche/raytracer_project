#include "file_readers/raw_data.hpp"
#include "screen/screen.hpp"
#include <stdio.h>

/* Creates a file file_name, and writes in it the resolution of the image, the number of rays used to generate it,
   and the raw data of the matrix
   Returns true if the operation was successful */
/* Format:

   width:1366 height:768 number_of_rays:10
   2550.0000000000 2000.0000000000 1367.4666666666
   ...
   
   width * height of 3 doubles (red, green, blue) separated by spaces,
   pixel (i,j) at line j*width + i
   line k representing pixel (k % width, k / width)
*/
bool export_raw(const char* file_name, const unsigned int number_of_rays, std::vector<std::vector<rt::color>>& matrix) {

    FILE* file = fopen(file_name, "w");

    if (file == NULL) {
        printf("Error, file %s could not be created\n", file_name);
        return false;
    }
    
    const unsigned int width = matrix.size();
    const unsigned int height = matrix.at(0).size();

    const int ret0 = fprintf(file, "width:%u height:%u number_of_rays:%u\n",
        width, height, number_of_rays);

    if (ret0 < 0) {
        printf("Writing error at first line of %s\n", file_name);
        fclose(file);
        return false;
    }

    for(unsigned int j = 0; j < height; j++) {
        for(unsigned int i = 0; i < width; i++) {
            rt::color c = matrix.at(i).at(j);
            const int ret = fprintf(file, "%lf %lf %lf\n", c.get_red(), c.get_green(), c.get_blue());
            if (ret < 0) {
                printf("Writing error at color line %u of %s\n", width*j + i, file_name);
                fclose(file);
                return false;
            }
        }
    }

    fclose(file);
    return true;
}

/* Reads a file file_name generated by export_raw, and returns a matrix with its content
   Returns true if the operation was successful */
std::vector<std::vector<rt::color>>& read_raw(const char* file_name, bool& success) {

    FILE* file = fopen(file_name, "r");

    if (file == NULL) {
        printf("Error, file %s not found\n", file_name);
        success = false;
        fclose(file);
        std::vector<std::vector<rt::color>>* fail_matrix = new std::vector<std::vector<rt::color>>(1, std::vector<rt::color>(1));
        return *fail_matrix;
    }

    unsigned int width, height, number_of_rays;
    const int ret0 = fscanf(file, "width:%u height:%u number_of_rays:%u\n",
        &width, &height, &number_of_rays);

    if (ret0 < 0) {
        printf("Reading error at first line of %s\n", file_name);
        success = false;
        fclose(file);
        std::vector<std::vector<rt::color>>* fail_matrix = new std::vector<std::vector<rt::color>>(1, std::vector<rt::color>(1));
        return *fail_matrix;
    }

    std::vector<std::vector<rt::color>>* matrix = new std::vector<std::vector<rt::color>>(width, std::vector<rt::color>(height));

    for(unsigned int j = 0; j < height; j++) {
        for(unsigned int i = 0; i < width; i++) {
            double r, g, b;
            const int ret = fscanf(file, "%lf %lf %lf\n", &r, &g, &b);
            if (ret < 0) {
                printf("Reading error at color line %u of %s\n", width*j + i, file_name);
                fclose(file);
                success = false;
                return *matrix;
            }
            (*matrix).at(i).at(j) = rt::color(r, g, b);
        }
    }

    fclose(file);

    success = true;
    return *matrix;
}